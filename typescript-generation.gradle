// TypeScript Generation Configuration
// This file contains all logic for generating TypeScript interfaces from Java DTO classes

// Task to generate TypeScript interfaces from DTO classes
task generateTypeScript {
    description 'Generate TypeScript interfaces from Java DTO classes'
    group = 'build'

    doLast {
        def outputDir = file("${projectDir}/test_management/build/types")
        if (!outputDir.exists()) {
            outputDir.mkdirs()
        }
        
        def outputFile = file("${outputDir}/tm-api-objects.ts")
        outputFile.text = generateTypeScriptInterfaces()
        println "TypeScript interfaces generated: ${outputFile.absolutePath}"
    }
}

// Make TypeScript generation run during build
build.dependsOn generateTypeScript

def generateTypeScriptInterfaces() {
    def interfaces = []
    
    // Find all DTO classes - use the correct source directory
    def dtoClasses = []
    fileTree(dir: "${projectDir}/test_management/src/main/java", include: '**/dto/*.java').visit { fileDetails ->
        if (fileDetails.file.name.endsWith('.java')) {
            dtoClasses << fileDetails.file
        }
    }
    
    dtoClasses.each { javaFile ->
        def className = javaFile.name.replace('.java', '')
        def packageName = extractPackageName(javaFile)
        def fullClassName = "${packageName}.${className}"
        
        def tsInterface = generateTypeScriptInterface(javaFile, className)
        if (tsInterface) {
            interfaces << tsInterface
        }
    }
    
    // Generate the complete TypeScript file
    return """// Auto-generated TypeScript interfaces from Java DTO classes
// Generated on: ${new Date().toString()}
// Do not edit manually - regenerate with: ./gradlew generateTypeScript

${interfaces.join('\n\n')}
"""
}

def extractPackageName(javaFile) {
    def content = javaFile.text
    def packageMatch = content =~ /package\s+([^;]+);/
    if (packageMatch.find()) {
        return packageMatch.group(1).replace('/', '.')
    }
    return ''
}

def generateTypeScriptInterface(javaFile, className) {
    def content = javaFile.text
    
    // Skip if it's not a DTO class
    if (!content.contains('extends ConfigDTO')) {
        return ''
    }
    
    def interfaceName = className.replace('DTO', '')
    def properties = []
    
    // Extract properties from the class
    def lines = content.split('\n')
    lines.each { line ->
        line = line.trim()
        
        // Look for private fields
        if (line.startsWith('private ') && !line.contains('static')) {
            def propertyMatch = line =~ /private\s+(\w+(?:<[^>]+>)?)\s+(\w+)/
            if (propertyMatch.find()) {
                def javaType = propertyMatch.group(1)
                def propertyName = propertyMatch.group(2)
                def tsType = mapJavaTypeToTypeScript(javaType)
                properties << "  ${propertyName}: ${tsType};"
            }
        }
    }
    
    // Add base properties from ConfigDTO
    properties.add("  standard: boolean;")
    properties.add("  identifier: string;")
    
    return """export interface ${interfaceName} {
${properties.join('\n')}
}"""
}

def mapJavaTypeToTypeScript(javaType) {
    switch (javaType) {
        case 'String':
            return 'string'
        case 'boolean':
        case 'Boolean':
            return 'boolean'
        case 'int':
        case 'Integer':
        case 'long':
        case 'Long':
        case 'double':
        case 'Double':
        case 'float':
        case 'Float':
            return 'number'
        case 'boolean[]':
            return 'boolean[]'
        case 'String[]':
            return 'string[]'
        case 'int[]':
        case 'Integer[]':
        case 'long[]':
        case 'Long[]':
        case 'double[]':
        case 'Double[]':
        case 'float[]':
        case 'Float[]':
            return 'number[]'
        default:
            // For complex types, use 'any' for now
            return 'any'
    }
}
