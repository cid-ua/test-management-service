plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.clarity'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.mariadb.jdbc:mariadb-java-client'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    
    // TypeScript generation dependencies
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.15.2'
    implementation 'javax.annotation:javax.annotation-api:1.3.2'
}

tasks.named('test') {
    useJUnitPlatform()
}

// Task to generate TypeScript interfaces from DTO classes
task generateTypeScript {
    description 'Generate TypeScript interfaces from Java DTO classes'
    group = 'build'

    doLast {
        def outputDir = file("${projectDir}/test_management/build/types")
        if (!outputDir.exists()) {
            outputDir.mkdirs()
        }
        
        def outputFile = file("${outputDir}/tm-api-objects.ts")
        outputFile.text = generateTypeScriptInterfaces()
        println "TypeScript interfaces generated: ${outputFile.absolutePath}"
    }
}

// Make TypeScript generation run during build
build.dependsOn generateTypeScript

def generateTypeScriptInterfaces() {
    def interfaces = []
    
    // Find all DTO classes - use the correct source directory
    def dtoClasses = []
    fileTree(dir: "${projectDir}/test_management/src/main/java", include: '**/dto/*.java').visit { fileDetails ->
        if (fileDetails.file.name.endsWith('.java')) {
            dtoClasses << fileDetails.file
        }
    }
    
    dtoClasses.each { javaFile ->
        def className = javaFile.name.replace('.java', '')
        def packageName = extractPackageName(javaFile)
        def fullClassName = "${packageName}.${className}"
        
        def tsInterface = generateTypeScriptInterface(javaFile, className)
        if (tsInterface) {
            interfaces << tsInterface
        }
    }
    
    // Generate the complete TypeScript file
    return """// Auto-generated TypeScript interfaces from Java DTO classes
// Generated on: ${new Date().toString()}
// Do not edit manually - regenerate with: ./gradlew generateTypeScript

${interfaces.join('\n\n')}
"""
}

def extractPackageName(javaFile) {
    def content = javaFile.text
    def packageMatch = content =~ /package\\s+([^;]+);/
    if (packageMatch.find()) {
        return packageMatch.group(1).replace('/', '.')
    }
    return ''
}

def generateTypeScriptInterface(javaFile, className) {
    def content = javaFile.text
    
    // Skip if it's not a DTO class
    if (!content.contains('extends ConfigDTO')) {
        return ''
    }
    
    def interfaceName = className.replace('DTO', '')
    def properties = []
    
    // Extract properties from the class
    def lines = content.split('\\n')
    lines.each { line ->
        line = line.trim()
        
        // Look for private fields
        if (line.startsWith('private ') && !line.contains('static')) {
            def propertyMatch = line =~ /private\\s+(\\w+(?:<[^>]+>)?)\\s+(\\w+)/
            if (propertyMatch.find()) {
                def javaType = propertyMatch.group(1)
                def propertyName = propertyMatch.group(2)
                def tsType = mapJavaTypeToTypeScript(javaType)
                properties << "  ${propertyName}: ${tsType};"
            }
        }
    }
    
    // Add base properties from ConfigDTO
    properties.add("  standard: boolean;")
    properties.add("  identifier: string;")
    
    return """export interface ${interfaceName} {
${properties.join('\n')}
}"""
}

def mapJavaTypeToTypeScript(javaType) {
    switch (javaType) {
        case 'String':
            return 'string'
        case 'boolean':
        case 'Boolean':
            return 'boolean'
        case 'int':
        case 'Integer':
        case 'long':
        case 'Long':
        case 'double':
        case 'Double':
        case 'float':
        case 'Float':
            return 'number'
        case 'boolean[]':
            return 'boolean[]'
        case 'String[]':
            return 'string[]'
        case 'int[]':
        case 'Integer[]':
        case 'long[]':
        case 'Long[]':
        case 'double[]':
        case 'Double[]':
        case 'float[]':
        case 'Float[]':
            return 'number[]'
        default:
            // For complex types, use 'any' for now
            return 'any'
    }
}
